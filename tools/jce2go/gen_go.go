package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io/ioutil"
	"os"
	"path/filepath"
	"runtime"
	"strconv"
	"strings"
)

// 全局 map 避免重复生成
var (
	fileMap = make(map[string]bool, 0)
)

// Generate record go code information.
// 代码生成
type Generate struct {
	I         []string     // imports with path
	code      bytes.Buffer // 最终生成的代码
	vc        int          // var count. Used to generate unique variable names
	filepath  string       // 当前解析的 jce 文件
	codecPath string       // 生成后的代码依赖的基础 codec 代码
	module    string       // 包名
	prefix    string       // 最终的生成目录
	p         *Parse       // 当前文件生成的语法分析树
}

// NewGenerate build up a new path
func NewGenerate(path string, module string, outdir string) *Generate {
	if outdir != "" {
		b := []byte(outdir)
		last := b[len(b)-1:]
		if string(last) != "/" {
			outdir += "/"
		}
	}

	return &Generate{
		I:        []string{},
		code:     bytes.Buffer{},
		vc:       0,
		filepath: path,

		codecPath: "github.com/edte/erpc/codec/jce",
		module:    module,
		prefix:    outdir,
		p:         &Parse{},
	}
}

// Gen to parse file.
func (gen *Generate) Gen() {
	// recover  panic
	defer func() {
		if err := recover(); err != nil {
			fmt.Println(err)
			os.Exit(1)
		}
	}()

	// 解析文件
	gen.p = ParseFile(gen.filepath, make([]string, 0))

	// fmt.Println()
	// b, _ := json.Marshal(gen.p)
	// fmt.Println(string(b))

	// 开始代码生成
	gen.genAll()
}

func (gen *Generate) genAll() {
	if fileMap[gen.filepath] {
		return
	}

	if len(gen.p.Enum) == 0 && len(gen.p.Const) == 0 && len(gen.p.Struct) == 0 {
		return
	}

	gen.genIncludeFiles()
	gen.genFileComment()
	gen.genPackage()
	gen.genEnums()
	gen.genConst()
	gen.genStructs()
	gen.saveFiles()

	fileMap[gen.filepath] = true
}

// 先生成依赖的其他文件，即 include 的其他文件
func (gen *Generate) genIncludeFiles() {
	for _, v := range gen.p.IncParse {
		NewGenerate(v.Source, gen.module, gen.prefix).genAll()
	}
}

// genFileComment 写文件注释
func (gen *Generate) genFileComment() {
	gen.writeString(`// DO NOT EDIT IT.` + ` 
// code generated by jce2go ` + VERSION + `. 
// source: ` + filepath.Base(gen.filepath) + `
`)
}

// genPackage 写包名、导第三方包
func (gen *Generate) genPackage() {
	// [setp 1] 包名
	gen.writeString("package " + gen.p.Module + "\n\n")

	// [step 2] 导基础包
	gen.writeString(`
import (
	"fmt"
    "io"

`)

	// [step 3] 包依赖的第三方包
	gen.genImports()

	// [step 4] 写占位
	gen.writeString(`)

    // 占位使用，避免导入的这些包没有被使用
	var _ = fmt.Errorf
    var _ = io.ReadFull
    var _ = jce.BYTE

`)

}

// 导第三方包
func (gen *Generate) genImports() {
	// [step 1] 导 jce 编码包
	gen.writeString("\"" + gen.codecPath + "\"\n")

	// [step 2] 导 struct 依赖的包
	for _, st := range gen.p.Struct {
		for k := range st.DependModule {
			gen.genStructImport(k)
		}
	}
}

// 导 struct 依赖的包
func (gen *Generate) genStructImport(module string) {
	moduleStr := module

	for _, p := range gen.I {
		if strings.HasSuffix(p, "/"+moduleStr) {
			gen.writeString(`"` + moduleStr + `"` + "\n")
			return
		}
	}

	if gen.module == "" {
		return
	}

	mf := filepath.Clean(filepath.Join(gen.module, gen.prefix))

	if runtime.GOOS == "windows" {
		mf = strings.ReplaceAll(mf, string(os.PathSeparator), string('/'))
	}

	moduleStr = fmt.Sprintf("%s/%s", mf, moduleStr)

	gen.writeString(`"` + moduleStr + `"` + "\n")

	return
}

// 写枚举
func (gen *Generate) genEnums() {
	for _, v := range gen.p.Enum {
		gen.genEnum(&v)
	}
}

func (gen *Generate) genEnum(en *EnumInfo) {
	if len(en.Mb) == 0 {
		return
	}

	en.rename()

	gen.writeString("type " + en.Name + " int32\n")
	gen.writeString("const (\n")

	var it int32

	for _, v := range en.Mb {
		if v.Type == 0 {
			//use value
			gen.writeString(gen.makeEnumName(en, &v) + " " + en.Name + ` = ` + strconv.Itoa(int(v.Value)) + "\n")
			it = v.Value + 1
		} else if v.Type == 1 {
			// use name
			find := false
			for _, ref := range en.Mb {
				if ref.Key == v.Name {
					find = true
					gen.writeString(gen.makeEnumName(en, &v) + " " + en.Name + ` = ` + gen.makeEnumName(en, &ref) + "\n")
					it = ref.Value + 1
					break
				}
				if ref.Key == v.Key {
					break
				}
			}
			if !find {
				panic(v.Name + " not define before use.")
			}
		} else {
			// use auto add
			gen.writeString(gen.makeEnumName(en, &v) + " " + en.Name + ` = ` + strconv.Itoa(int(it)) + "\n")
			it++
		}

	}

	gen.writeString(")\n")
}

func (gen *Generate) makeEnumName(en *EnumInfo, mb *EnumMember) string {
	return upperFirstLetter(en.Name) + "_" + upperFirstLetter(mb.Key)
}

func (gen *Generate) genConst() {
	if len(gen.p.Const) == 0 {
		return
	}

	gen.writeString("//const as define in jce file\n")
	gen.writeString("const (\n")

	for _, v := range gen.p.Const {
		v.rename()
		gen.writeString(v.Name + " " + gen.genType(v.Type) + " = " + v.Value + "\n")
	}

	gen.writeString(")\n")
}

func (gen *Generate) genStructs() {
	for _, v := range gen.p.Struct {
		gen.genStruct(&v)
	}
}

func (gen *Generate) genStruct(st *StructInfo) {
	gen.vc = 0
	st.rename()

	gen.genStructDefine(st)
	gen.genFunResetDefault(st)

	gen.genFunReadFrom(st)
	gen.genFunReadBlock(st)

	gen.genFunWriteTo(st)
	gen.genFunWriteBlock(st)
}

func errString(hasRet bool) string {
	var retStr string
	if hasRet {
		retStr = "return ret, err"
	} else {
		retStr = "return err"
	}
	return `if err != nil {
  ` + retStr + `
  }` + "\n"
}

func genForHead(vc string) string {
	i := `i` + vc
	e := `e` + vc
	return ` for ` + i + `,` + e + ` := int32(0), length;` + i + `<` + e + `;` + i + `++ `
}

func (gen *Generate) genVariableName(prefix, name string) string {
	if prefix != "" {
		return prefix + name
	} else {
		return strings.Trim(name, "()")
	}
}

func (gen *Generate) genType(ty *VarType) string {
	ret := ""

	switch ty.Type {
	case tkTBool:
		ret = "bool"
	case tkTInt:
		if ty.Unsigned {
			ret = "uint32"
		} else {
			ret = "int32"
		}
	case tkTShort:
		if ty.Unsigned {
			ret = "uint16"
		} else {
			ret = "int16"
		}
	case tkTByte:
		if ty.Unsigned {
			ret = "uint8"
		} else {
			ret = "int8"
		}
	case tkTLong:
		if ty.Unsigned {
			ret = "uint64"
		} else {
			ret = "int64"
		}
	case tkTFloat:
		ret = "float32"
	case tkTDouble:
		ret = "float64"
	case tkTString:
		ret = "string"
	case tkTVector:
		ret = "[]" + gen.genType(ty.TypeK)
	case tkTMap:
		ret = "map[" + gen.genType(ty.TypeK) + "]" + gen.genType(ty.TypeV)
	case tkName:
		ret = strings.Replace(ty.TypeSt, "::", ".", -1)
		vec := strings.Split(ty.TypeSt, "::")
		for i := range vec {
			if i == (len(vec) - 1) {
				vec[i] = upperFirstLetter(vec[i])
			}
		}
		ret = strings.Join(vec, ".")
	case tkTArray:
		ret = "[" + fmt.Sprintf("%v", ty.TypeL) + "]" + gen.genType(ty.TypeK)
	default:
		panic("Unknown Type " + TokenMap[ty.Type])
	}

	return ret
}

func (gen *Generate) genStructDefine(st *StructInfo) {
	gen.writeString("// " + st.Name + " struct implement\n")
	gen.writeString("type " + st.Name + " struct {\n")

	for _, v := range st.Mb {
		if jsonOmitEmpty {
			gen.writeString("\t" + v.Key + " " + gen.genType(v.Type) + " `json:\"" + v.OriginKey + ",omitempty\"`\n")
		} else {
			gen.writeString("\t" + v.Key + " " + gen.genType(v.Type) + " `json:\"" + v.OriginKey + "\"`\n")
		}
	}
	gen.writeString("}\n")
}

func (gen *Generate) genFunResetDefault(st *StructInfo) {
	gen.writeString("func (st *" + st.Name + ") ResetDefault() {\n")

	for _, v := range st.Mb {
		if v.Type.CType == tkStruct {
			gen.writeString("st." + v.Key + ".ResetDefault()\n")
		}
		if v.Default == "" {
			continue
		}
		gen.writeString("st." + v.Key + " = " + v.Default + "\n")
	}
	gen.writeString("}\n")
}

func (gen *Generate) genWriteSimpleList(mb *StructMember, prefix string, hasRet bool) {
	tag := strconv.Itoa(int(mb.Tag))
	errStr := errString(hasRet)

	if mb.Type.TypeK.Unsigned {
		gen.writeString(`
err = buf.WriteSliceUint8(` + gen.genVariableName(prefix, mb.Key) + `,` + tag + `,` + `)
` + errStr + `
`)
		return
	}

	gen.writeString(`
err = buf.WriteSliceInt8(` + gen.genVariableName(prefix, mb.Key) + `,` + tag + `,` + `)
` + errStr + `
`)
}

func (gen *Generate) genWriteVector(mb *StructMember, prefix string, hasRet bool) {
	// SimpleList
	if mb.Type.TypeK.Type == tkTByte && !mb.Type.TypeK.Unsigned {
		gen.genWriteSimpleList(mb, prefix, hasRet)
		return
	}
	errStr := errString(hasRet)

	// LIST
	tag := strconv.Itoa(int(mb.Tag))
	gen.writeString(`
err = buf.WriteHead(jce.LIST, ` + tag + `)
` + errStr + `
err = buf.WriteInt32(int32(len(` + gen.genVariableName(prefix, mb.Key) + `)), 0)
` + errStr + `
for _, v := range ` + gen.genVariableName(prefix, mb.Key) + ` {
`)
	// for _, v := range can nesting for _, v := range，does not conflict, support multidimensional arrays

	dummy := &StructMember{}
	dummy.Type = mb.Type.TypeK
	dummy.Key = "v"
	gen.genWriteVar(dummy, "", hasRet)

	gen.writeString("}\n")
}

func (gen *Generate) genWriteArray(mb *StructMember, prefix string, hasRet bool) {
	// SimpleList
	if mb.Type.TypeK.Type == tkTByte && !mb.Type.TypeK.Unsigned {
		gen.genWriteSimpleList(mb, prefix, hasRet)
		return
	}
	errStr := errString(hasRet)

	// LIST
	tag := strconv.Itoa(int(mb.Tag))
	gen.writeString(`
err = buf.WriteHead(jce.LIST, ` + tag + `)
` + errStr + `
err = buf.WriteInt32(int32(len(` + gen.genVariableName(prefix, mb.Key) + `)), 0)
` + errStr + `
for _, v := range ` + gen.genVariableName(prefix, mb.Key) + ` {
`)
	// for _, v := range can nesting for _, v := range，does not conflict, support multidimensional arrays

	dummy := &StructMember{}
	dummy.Type = mb.Type.TypeK
	dummy.Key = "v"
	gen.genWriteVar(dummy, "", hasRet)

	gen.writeString("}\n")
}

func (gen *Generate) genWriteStruct(mb *StructMember, prefix string, hasRet bool) {
	tag := strconv.Itoa(int(mb.Tag))
	gen.writeString(`
err = ` + prefix + mb.Key + `.WriteBlock(buf, ` + tag + `)
` + errString(hasRet) + `
`)
}

func (gen *Generate) genWriteMap(mb *StructMember, prefix string, hasRet bool) {
	tag := strconv.Itoa(int(mb.Tag))
	vc := strconv.Itoa(gen.vc)
	gen.vc++
	errStr := errString(hasRet)
	gen.writeString(`
err = buf.WriteHead(jce.MAP, ` + tag + `)
` + errStr + `
err = buf.WriteInt32(int32(len(` + gen.genVariableName(prefix, mb.Key) + `)), 0)
` + errStr + `
for k` + vc + `, v` + vc + ` := range ` + gen.genVariableName(prefix, mb.Key) + ` {
`)
	// for _, v := range can nesting for _, v := range，does not conflict, support multidimensional arrays

	dummy := &StructMember{}
	dummy.Type = mb.Type.TypeK
	dummy.Key = "k" + vc
	gen.genWriteVar(dummy, "", hasRet)

	dummy = &StructMember{}
	dummy.Type = mb.Type.TypeV
	dummy.Key = "v" + vc
	dummy.Tag = 1
	gen.genWriteVar(dummy, "", hasRet)

	gen.writeString("}\n")
}

func (gen *Generate) genWriteVar(v *StructMember, prefix string, hasRet bool) {
	switch v.Type.Type {
	case tkTVector:
		gen.genWriteVector(v, prefix, hasRet)
	case tkTArray:
		gen.genWriteArray(v, prefix, hasRet)
	case tkTMap:
		gen.genWriteMap(v, prefix, hasRet)
	case tkName:
		if v.Type.CType == tkEnum {
			// tkEnum enumeration processing
			tag := strconv.Itoa(int(v.Tag))
			gen.writeString(`
err = buf.WriteInt32(int32(` + gen.genVariableName(prefix, v.Key) + `),` + tag + `)
` + errString(hasRet) + `
`)
		} else {
			gen.genWriteStruct(v, prefix, hasRet)
		}
	default:
		tag := strconv.Itoa(int(v.Tag))
		gen.writeString(`
err = buf.Write` + upperFirstLetter(gen.genType(v.Type)) + `(` + gen.genVariableName(prefix, v.Key) + `, ` + tag + `)
` + errString(hasRet) + `
`)
	}
}

func (gen *Generate) genFunWriteBlock(st *StructInfo) {
	// WriteBlock function head
	gen.writeString(`// WriteBlock encode struct
func (st *` + st.Name + `) WriteBlock(w io.Writer, tag byte) (err error) {
    buf := jce.NewEncoder(w)

	if err = buf.WriteHead(jce.StructBegin, tag);err != nil {
        return
    }

	if err = st.WriteTo(w);err != nil {
        return
    }

	if err = buf.WriteHead(jce.StructEnd, 0);err!=nil {
        return 
    }

	return
}
`)
}

func (gen *Generate) genFunWriteTo(st *StructInfo) {
	gen.writeString(`// WriteTo encode struct to buffer
func (st *` + st.Name + `) WriteTo(w io.Writer) (err error) {
    buf := jce.NewEncoder(w)
`)
	for _, v := range st.Mb {
		gen.genWriteVar(&v, "st.", false)
	}

	gen.writeString(`
    return buf.Flush()
}
`)
}

func (gen *Generate) genReadSimpleList(mb *StructMember, prefix string, hasRet bool) {
	unsign := "Int8"

	if mb.Type.TypeK.Unsigned {
		unsign = "Uint8"
	}

	errStr := errString(hasRet)

	gen.writeString(`
_, err = readBuf.SkipTo(jce.BYTE, 0, true)
` + errStr + `
err = readBuf.ReadInt32(&length, 0, true)
` + errStr + `
err = readBuf.ReadSlice` + unsign + `(&` + prefix + mb.Key + `, length, true)
` + errStr + `
`)
}

func (gen *Generate) genReadVector(mb *StructMember, prefix string, hasRet bool) {
	errStr := errString(hasRet)

	// LIST
	tag := strconv.Itoa(int(mb.Tag))
	vc := strconv.Itoa(gen.vc)
	gen.vc++
	require := "false"

	if mb.Require {
		require = "true"
	}

	if require == "false" {
		gen.writeString(`
have, ty, err = readBuf.SkipToNoCheck(` + tag + `,` + require + `)
` + errStr + `
if have {`)
	} else {
		gen.writeString(`
_, ty, err = readBuf.SkipToNoCheck(` + tag + `,` + require + `)
` + errStr + `
`)
	}

	gen.writeString(`
if ty == jce.LIST {
	err = readBuf.ReadInt32(&length, 0, true)
  ` + errStr + `
  ` + gen.genVariableName(prefix, mb.Key) + ` = make(` + gen.genType(mb.Type) + `, length)
  ` + genForHead(vc) + `{
`)

	dummy := &StructMember{}
	dummy.Type = mb.Type.TypeK
	dummy.Key = mb.Key + "[i" + vc + "]"
	gen.genReadVar(dummy, prefix, hasRet)

	gen.writeString(`}
} else if ty == jce.SimpleList {
`)

	if mb.Type.TypeK.Type == tkTByte {
		gen.genReadSimpleList(mb, prefix, hasRet)
	} else {
		gen.writeString(`err = fmt.Errorf("not support SimpleList type")
    ` + errStr)
	}

	gen.writeString(`
} else {
  err = fmt.Errorf("require vector, but not")
  ` + errStr + `
}
`)

	if require == "false" {
		gen.writeString("}\n")
	}
}

func (gen *Generate) genReadArray(mb *StructMember, prefix string, hasRet bool) {
	errStr := errString(hasRet)

	// LIST
	tag := strconv.Itoa(int(mb.Tag))
	vc := strconv.Itoa(gen.vc)
	gen.vc++
	require := "false"
	if mb.Require {
		require = "true"
	}

	if require == "false" {
		gen.writeString(`
have, ty, err = readBuf.SkipToNoCheck(` + tag + `,` + require + `)
` + errStr + `
if have {`)
	} else {
		gen.writeString(`
_, ty, err = readBuf.SkipToNoCheck(` + tag + `,` + require + `)
` + errStr + `
`)
	}

	gen.writeString(`
if ty == jce.LIST {
	err = readBuf.ReadInt32(&length, 0, true)
  ` + errStr + `
  ` + genForHead(vc) + `{
`)

	dummy := &StructMember{}
	dummy.Type = mb.Type.TypeK
	dummy.Key = mb.Key + "[i" + vc + "]"
	gen.genReadVar(dummy, prefix, hasRet)

	gen.writeString(`}
} else if ty == jce.SimpleList {
`)
	if mb.Type.TypeK.Type == tkTByte {
		gen.genReadSimpleList(mb, prefix, hasRet)
	} else {
		gen.writeString(`err = fmt.Errorf("not support SimpleList type")
    ` + errStr)
	}
	gen.writeString(`
} else {
  err = fmt.Errorf("require array, but not")
  ` + errStr + `
}
`)

	if require == "false" {
		gen.writeString("}\n")
	}
}

func (gen *Generate) genReadStruct(mb *StructMember, prefix string, hasRet bool) {
	tag := strconv.Itoa(int(mb.Tag))
	require := "false"
	if mb.Require {
		require = "true"
	}
	gen.writeString(`
err = ` + prefix + mb.Key + `.ReadBlock(readBuf, ` + tag + `, ` + require + `)
` + errString(hasRet) + `
`)
}

func (gen *Generate) genReadMap(mb *StructMember, prefix string, hasRet bool) {
	tag := strconv.Itoa(int(mb.Tag))
	errStr := errString(hasRet)
	vc := strconv.Itoa(gen.vc)
	gen.vc++
	require := "false"
	if mb.Require {
		require = "true"
	}

	if require == "false" {
		gen.writeString(`
have, err = readBuf.SkipTo(jce.MAP, ` + tag + `, ` + require + `)
` + errStr + `
if have {`)
	} else {
		gen.writeString(`
_, err = readBuf.SkipTo(jce.MAP, ` + tag + `, ` + require + `)
` + errStr + `
`)
	}

	gen.writeString(`
err = readBuf.ReadInt32(&length, 0, true)
` + errStr + `
` + gen.genVariableName(prefix, mb.Key) + ` = make(` + gen.genType(mb.Type) + `)
` + genForHead(vc) + `{
	var k` + vc + ` ` + gen.genType(mb.Type.TypeK) + `
	var v` + vc + ` ` + gen.genType(mb.Type.TypeV) + `
`)

	dummy := &StructMember{}
	dummy.Type = mb.Type.TypeK
	dummy.Key = "k" + vc
	gen.genReadVar(dummy, "", hasRet)

	dummy = &StructMember{}
	dummy.Type = mb.Type.TypeV
	dummy.Key = "v" + vc
	dummy.Tag = 1

	gen.genReadVar(dummy, "", hasRet)

	gen.writeString(`
	` + prefix + mb.Key + `[k` + vc + `] = v` + vc + `
}
`)
	if require == "false" {
		gen.writeString("}\n")
	}
}

func (gen *Generate) genReadVar(v *StructMember, prefix string, hasRet bool) {
	switch v.Type.Type {
	case tkTVector:
		gen.genReadVector(v, prefix, hasRet)
	case tkTArray:
		gen.genReadArray(v, prefix, hasRet)
	case tkTMap:
		gen.genReadMap(v, prefix, hasRet)
	case tkName:
		if v.Type.CType == tkEnum {
			tag := strconv.Itoa(int(v.Tag))
			require := "false"
			if v.Require {
				require = "true"
			}
			gen.writeString(`
err = readBuf.ReadInt32((*int32)(&` + prefix + v.Key + `),` + tag + `, ` + require + `)
` + errString(hasRet) + `
`)
		} else {
			gen.genReadStruct(v, prefix, hasRet)
		}
	default:
		tag := strconv.Itoa(int(v.Tag))
		require := "false"
		if v.Require {
			require = "true"
		}
		gen.writeString(`
err = readBuf.Read` + upperFirstLetter(gen.genType(v.Type)) + `(&` + prefix + v.Key + `, ` + tag + `, ` + require + `)
` + errString(hasRet) + `
`)
	}
}

func (gen *Generate) genFunReadFrom(st *StructInfo) {
	gen.writeString(`// ReadFrom reads  from readBuf and put into struct.
func (st *` + st.Name + `) ReadFrom(r io.Reader) (err error) {
	var (
		length int32
		have bool
		ty byte
	)

    readBuf := jce.NewDecoder(r)
	st.ResetDefault()

`)

	for _, v := range st.Mb {
		gen.genReadVar(&v, "st.", false)
	}

	gen.code.WriteString(`
	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}
`)
}

func (gen *Generate) genFunReadBlock(st *StructInfo) {
	gen.writeString(`// ReadBlock reads struct from the given tag , require or optional.
func (st *` + st.Name + `) ReadBlock(r io.Reader, tag byte, require bool) error {
	var (
		err error
		have bool
	)

    readBuf := jce.NewDecoder(r)

	st.ResetDefault()

	have, err = readBuf.SkipTo(jce.StructBegin, tag, require)
	if err != nil {
		return err
	}

	if !have {
		if require {
			return fmt.Errorf("require ` + st.Name + `, but not exist. tag %d", tag)
		}
		return nil
	}

  	err = st.ReadFrom(r)
  	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}

	_ = have
	return nil
}
`)
}

func (gen *Generate) saveFiles() {
	if debug {
		fmt.Println("------------------------------------------------------")
		fmt.Println(gen.code.String())
		fmt.Println("------------------------------------------------------")
	}

	filename := gen.p.ProtoName + ".jce.go"

	beauty, err := format.Source(gen.code.Bytes())
	if err != nil {
		panic("go fmt fail. " + filename + " " + err.Error())
	}

	mkPath := gen.prefix + gen.p.Module

	if err = os.MkdirAll(mkPath, 0766); err != nil {
		panic(err.Error())
	}

	if err = ioutil.WriteFile(mkPath+"/"+filename, beauty, 0666); err != nil {
		panic(err.Error())
	}
}

func upperFirstLetter(s string) string {
	if len(s) == 0 {
		return ""
	}

	if len(s) == 1 {
		return strings.ToUpper(string(s[0]))
	}

	return strings.ToUpper(string(s[0])) + s[1:]
}

func (gen *Generate) writeString(s string) (err error) {
	_, err = gen.code.WriteString(s)
	return
}
